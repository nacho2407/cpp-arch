# Boost.Asio

크로스 플랫폼을 지향하는 C++ 표준은, 지속적으로 발전하여 지금은 멀티 쓰레딩이나 Boost C++ Libraries에 포함된 여러 편리한 기능들을 포함하고 있지만 여전히 네트워크 관련 기능은 플랫폼에 종속적이고 명시된 표준이 없다.

Boost.Asio 라이브러리는 다양한 플랫폼들(Microsoft Windows, POSIX)을 지원하기에 플랫폼 독립적인 C++ 코드를 작성할 수 있어 C++ 비동기 네트워크 프로그래밍에서 많이 사용하는 라이브러리다. 비동기 작업 목적으로 많이 사용하는 라이브러리지만, C++ 표준에 비동기 작업 라이브러리 [`<future>`](../../std/doc/asynchronous_threading.md#stdpromiset-stdfuturet)가 추가된 후로는 주로 네트워킹 작업에 많이 사용된다.


## Boost C++ Libraries

&nbsp;1.87.0 버전을 기준으로 설명한다.


&nbsp;[Boost C++ Libraries](https://www.boost.org/)(이하 Boost)는 C++ 생태계에서 매우 많이 사용되는 플랫폼 독립적 라이브러리 집합으로, Boost.Asio 뿐 아니라 C++ 프로그래밍에 도움이 될 수 있는 많은 라이브러리들을 포함하고 있다. Boost에 포함된 기능이 C++ 표준에 포함되는 것들이 많은데, 대표적으로 [스마트 포인터](../../std/doc/smart_pointers.md), [정규식](../../std/doc/regular_expressions.md), [함수 객체](../../std/doc/functional.md) 등이 있다. 이는 Boost 개발 커뮤니티의 많은 개발자가 C++ 표준 위원회에 속해 있기 때문이기도 한데, Boost는 현재 사실상 C++ 표준의 기능 시험장으로 여겨지는 경우도 있다.


&nbsp;Boost는 하나의 라이브러리가 아닌 라이브러리 집합이기 때문에 그 크기도 매우 방대한데, 때문에 실제로 Boost를 다운받을 때는 빌드할 수 있는 코드만 포함되어 있고, 일부 헤더 전용 라이브러리(대표적으로 Boost.Asio)를 제외하면 대부분의 라이브러리를 `b2`(Boost.Build)를 이용해 직접 빌드하여 사용해야 한다.


&nbsp;Microsoft Windows(이하 Windows) 기준으로 Boost를 설치하는 방법은 다음과 같다. Boost 설치 위치를 환경 변수 Path에 등록해둔 후, 우선 `bootstrap.bat`을 이용하여 `b2`를 빌드한다. Windows에서 구현된 Boost는 기본 툴체인이 MSVC로 되어있기 때문에 LLVM(`clang`)이나 mingw-w64(`gcc`)를 사용하는 경우 툴체인 정보를 추가로 넘겨주어야 한다. 이후 `b2`를 이용해 필요한 라이브러리를 빌드하는데, Boost.Asio 사용에 필요한 라이브러리인 Boost.System은 Boost의 많은 라이브러리에서 사용하므로 빌드해두는 것이 좋다.

```Shell
b2 --with-system -j<생성할 쓰레드 수> toolset=<사용할 컴파일러 이름> stage
```

&nbsp;사용할 라이브러리는 `--with-<라이브러리 이름>`으로 명시한다. 마지막의 `stage`는 라이브러리를 빌드할 폴더 이름으로, 원한다면 다른 이름으로 사용해도 된다.


&nbsp;이후 Boost와 함께 빌드하기 위해 컴파일 시 `-I<Boost 설치 경로>`, `-L<빌드한 Boost 라이브러리 경로(일반적으로 stage)>`를 추가한다. MSVC로 빌드할 때는 문제없이 잘 작동하는데 Windows 환경에서 다른 툴체인을 사용하면 공식 문서에서도 안 알려주는 필요 라이브러리들을 직접 찾아 추가해야하는 경우가 많다. 예를 들어 Boost.Asio를 이용하여 소켓 네트워킹을 하기 위해서는 Windows의 Winsock2 라이브러리를 함께 컴파일해야하는데 아무도 안 알려주기 때문에 직접 컴파일 에러 확인하면서 의존하는 라이브러리를 하나하나 추가해주어야 한다.


## Context

&nbsp;비동기 네트워크 프로그래밍에서 컨텍스트(Context / 문맥)라는 말이 자주 등장한다. 기존에 컨텍스트 없이 수행하던 비동기 작업은 하나의 프로세스 / 쓰레드에 종속되어 돌아갔지만 컨텍스트의 개념이 등장한 이후로는 하나의 프로그램에서 여러 컨텍스트로 나누어진 비동기 작업을 수행할 수 있게 되었다. 비유하자면 비동기 작업들은 사무실에서 각 직원들이 알아서 자신이 하는 일들이고, 컨텍스트는 그 직원들이 모인 사무실이라고 할 수 있다. 하나의 프로그램에서 여러 사무실을 두어 각각 자기의 부서 관련 일들을 비동기적으로 처리할 수 있는 것이다.


&nbsp;Boost.Asio에서는 이러한 컨텍스트를 `boost::asio::io_context`로 처리한다. 비동기 작업을 처리할 클래스들에 해당 컨텍스트를 넘겨주며 어느 사무실에 속한 직원인지를 알려준다. 사무실에서 일어나는 모든 비동기 작업은 컨텍스트에서 실행하고 중지할 수 있다. `boost::asio::io_context::run`은 컨텍스트를 실행 중인 상태로 만들어 비동기 루프를 시작하고 모든 작업이 완료되면 반환한다.


&nbsp;실행 중 오류 발생등의 이유로 해당 컨텍스트를 정지하고 싶으면 `boost::asio::io_context::stop`을, 작업을 다시 시작하려면 `boost::asio::io_context::restart`를 한다. 비동기 소켓 네트워킹에서는 컨텍스트에 직접 작업을 추가하는 일은 많지 않지만, `boost::asio::io_context::post` 등을 통해 비동기 작업을 직접 추가하여 실행할 수 있다.


*작성중*
