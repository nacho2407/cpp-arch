# Rule of 5

객체 중심 C++ 프로그래밍을 하다보면 'C++에서 클래스 설계 시 복사 / 이동 / 소멸자 관련 멤버 함수를 어떻게 정의해야 하는가?'하는 구조 설계적인 고민이 들 때가 있다. 이에 대해 C++에는 프로그래머들이 관습적으로 따르는 규칙이 있는데, 그것이 바로 **Rule of 5**다.


## Rule of 3

Rule of 5는 C++98 / 03때부터 이어져 온 Rule of 3의 확장판이라 할 수 있다.

> 클래스가 자원을 소유하고 있다면, 다음 3가지 함수 중 하나라도 정의하면 나머지도 반드시 정의해야 한다.
>
> `~T()`: 소멸자
>
> `T(const T&)`: 복사 생성자
>
> `T& operator =(const T&)`: 복사 대입 연산자

이러한 규칙이 필요한 이유는, 예를 들어 문자열을 동적으로 할당받아 `char*` 포인터에 저장한 상태라고 가정할 때, 복사 생성자만 정의하고 나머지를 생략하면 복사 대입 연산 시 얕은 복사(Shallow Copy)로 인한 Double Free 문제, Use-after-free 문제 등이 발생할 수 있기 때문이다(소멸자의 경우도 동일한 이유).


## Rule of 5

C++11에서 이동 문법이 도입되면서, 기존 Rule of 3에 이동 관련 멤버 함수 2개가 추가되었다.

> `~T()`: 소멸자
>
> `T(const T&)`: 복사 생성자
>
> `T& operator =(const T&)`: 복사 대입 연산자
>
> `T(T&&)`: 이동 생성자(`std::move(obj)` 사용 시 호출)
>
> `T& operator =(T&&)`: 이동 대입 연산자(`std::move(obj)`를 이용해 값을 이동할 때 호출)

객체의 복사를 막을 필요는 있지만 이동은 허용할 수 있는 경우(`std::unique_ptr` 등)가 존재하기 때문에 Rule of 5가 필요하다. 만약 이동 생성자만 정의하고 복사 생성자는 정의하지 않았다면 컴파일러는 자동으로 복사 생성자를 생성하려고 시도하기 때문에 우리의 의도 / 예측과는 다르게 동작할 수 있다. 이런 경우에 **나머지 필요 없는 멤버 함수들은 모두 `delete` 처리를 명시적으로 해주는 것이 안전하다.**

참고로 이동 관련 문법은 모던 C++에서부터 사용되기 시작하였기에 하위 호환성을 위해서인지는 몰라도, **이동 생성자는 복사 생성자만 정의했다하더라도 자동으로 생성 시도되지 않는다.**

여기에 기본 생성자까지 포함하여 자동으로 생성하는 모든 멤버 함수를 통제하자는 의견도 있는데, 이를 보통 Rule of 6로 부른다.


## Rule of 0?

현대 C++ 프로그래밍에서는 스마트 포인터나 STL 등 현대적인 메모리 관리 도구들이 많기 때문에, **객체의 자원 관리를 모두 스마트 포인터나 컨테이너에 맡기고 복사 / 이동 / 소멸자를 신경쓰지 않도록 구현할 수도 있다.**

일반적으로 사용되는 용어는 아닌 것으로 보이나, 이를 **Rule of 0**라고 부른다.
