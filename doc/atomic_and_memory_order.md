# Atomic & Memory Order

&nbsp;우리는 코드를 통해서 컴퓨터에 명령을 내릴 때 우리가 명령한 순서대로 작동할 것이라고 생각하지만, 실제로 우리의 컴퓨터(컴파일러와 CPU)는 우리가 무엇을 명령하는지만 생각하고 순서는 자기가 더 빠르게 작동할 수 있는 순서대로 마음대로 조직하여 명령을 수행한다. 순서가 어떻게 되던 간에 우리가 의도한대로 결과만 제대로 나오면 사실 컴퓨터가 똑똑하게도 더 빠르게 연산을 수행하는 것이 문제가 되지 않지만, 문제는 이것이 하나의 쓰레드 기준으로만 결과를 올바르게 보장한다는 것이다.


&nbsp;이러한 특성은 멀티 쓰레드 프로그래밍에서는 큰 장애물이 된다. 더 빠르게 연산을 수행하는 것은 분명 큰 장점이지만 결과가 예상대로 나오지 않으면 아무 소용이 없다. C++에서는 이러한 문제를 해결하기 위해 `<atomic>`을 통해 명령어의 원자성(Atomicity)을 보장하는 방법들을 제공한다. 원자적 연산이란, 더이상 쪼개질 수 없는 하나의 단위로 실행되는 연산으로, 다른 연산이 중간에 끼어들거나 중단되지 않음을 보장하는 것이다.


```C++
#include <functional>
#include <iostream>
#include <thread>

void up(int& i)
{
        i++;
}

int main(void)
{
        static int i = 0;

        std::thread t1(up, std::ref(i));
        std::thread t2(up, std::ref(i));

        t1.join();
        t2.join();
        
        std::cout << i << std::endl;

        return 0;
}
```

&nbsp;위의 코드에서 대표적으로 발생할 수 있는 경쟁 조건은 데이터의 불일치(Inconsistency)다. `t1`이 `i + 1`을 계산 후 결과를 `i`에 저장하기 전에 `t2`가 현재의 값을 읽어서 연산을 수행하면, 연산의 수행 결과는 `2`가 아니라 `1`이 될 수 있는 것이다. 이러한 문제를 해결하기 위해서는 `i`의 값을 읽고, `i + 1`을 수행한 다음, 이를 다시 `i`에 저장하는 일련의 연산의 중간에 다른 연산이 끼지 못하도록 원자성을 보장하는 것이다.

(작성중)
